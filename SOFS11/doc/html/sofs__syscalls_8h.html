<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SOFS11: sofs_syscalls.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>sofs_syscalls.h File Reference</h1>
<p>Set of operations to manage system calls.  
<a href="#_details">More...</a></p>
<code>#include &lt;unistd.h&gt;</code><br/>
<code>#include &lt;fcntl.h&gt;</code><br/>
<code>#include &lt;sys/types.h&gt;</code><br/>
<code>#include &lt;sys/statvfs.h&gt;</code><br/>
<code>#include &lt;sys/stat.h&gt;</code><br/>
<code>#include &lt;time.h&gt;</code><br/>
<code>#include &lt;utime.h&gt;</code><br/>
<code>#include &lt;libgen.h&gt;</code><br/>

<p><a href="sofs__syscalls_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#a1805c069be94614ff9fd88391e8da060">soMountSOFS</a> (const char *devname)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mount the SOFS10 file system.  <a href="#a1805c069be94614ff9fd88391e8da060"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#a18f674558eab695015444fa77af39e6d">soUnmountSOFS</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unmount the SOFS10 file system.  <a href="#a18f674558eab695015444fa77af39e6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#ac94558f3fd27529d5a81ed479025f18d">soStatFS</a> (const char *ePath, struct statvfs *st)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get file system statistics.  <a href="#ac94558f3fd27529d5a81ed479025f18d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#a6ce618672344fe2b4acbb61b1a0bc281">soStat</a> (const char *ePath, struct stat *st)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get file status.  <a href="#a6ce618672344fe2b4acbb61b1a0bc281"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#af81bf1bb69be42a3b0127b001368da50">soAccess</a> (const char *ePath, int opRequested)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check real user's permissions for a file.  <a href="#af81bf1bb69be42a3b0127b001368da50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#a04ec0ab1233ee30ab740387f7dc50569">soChmod</a> (const char *ePath, mode_t mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change permissions of a file.  <a href="#a04ec0ab1233ee30ab740387f7dc50569"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#a15ab14e6f57832e96fa6560795b23deb">soChown</a> (const char *ePath, uid_t owner, gid_t group)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the ownership of a file.  <a href="#a15ab14e6f57832e96fa6560795b23deb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#a8ffec27f63bab8cbdcaab645ef3b5e49">soUtime</a> (const char *ePath, const struct utimbuf *times)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the last access and modification times of a file.  <a href="#a8ffec27f63bab8cbdcaab645ef3b5e49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#a3548e2dc6fc347ee7c5b42f56131407d">soOpen</a> (const char *ePath, int flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a regular file.  <a href="#a3548e2dc6fc347ee7c5b42f56131407d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#a6a0d4b28380c3878ac4133afd5a47845">soClose</a> (const char *ePath)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close a regular file.  <a href="#a6a0d4b28380c3878ac4133afd5a47845"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#a8802ddd31f3e315d20778321251c3ce1">soFsync</a> (const char *ePath)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Synchronize a file's in-core state with storage device.  <a href="#a8802ddd31f3e315d20778321251c3ce1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#a2e4a5f041fbe2a91b5d93623e88dbe2f">soOpendir</a> (const char *ePath)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a directory for reading.  <a href="#a2e4a5f041fbe2a91b5d93623e88dbe2f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#aaa5da9eaa7db8ac7e5246884b973608e">soClosedir</a> (const char *ePath)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close a directory.  <a href="#aaa5da9eaa7db8ac7e5246884b973608e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#a937c048ec74c55af02c40c349f85af5d">soLink</a> (const char *oldPath, const char *newPath)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a new name for a file.  <a href="#a937c048ec74c55af02c40c349f85af5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#a276629202749786d8c570ce67ed6f9b9">soUnlink</a> (const char *ePath)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete the name of a file from a directory and possibly the file it refers to from the file system.  <a href="#a276629202749786d8c570ce67ed6f9b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#abea00e56afa699dc0a3c118304e0e15c">soRename</a> (const char *oldPath, const char *newPath)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the name or the location of a file in the directory hierarchy of the file system.  <a href="#abea00e56afa699dc0a3c118304e0e15c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#abc771321231500d8e3b51b25e1b9a919">soMknod</a> (const char *ePath, mode_t mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a regular file with size 0.  <a href="#abc771321231500d8e3b51b25e1b9a919"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#a8accfb94c629e0f1a22531188380def7">soRead</a> (const char *ePath, void *buff, uint32_t count, int32_t pos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read data from an open regular file.  <a href="#a8accfb94c629e0f1a22531188380def7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#a3cd31d386946336f121be6a4c0c696b8">soWrite</a> (const char *ePath, void *buff, uint32_t count, int32_t pos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write data into an open regular file.  <a href="#a3cd31d386946336f121be6a4c0c696b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#ac73c92cbdac16bd6b953313163f62a95">soTruncate</a> (const char *ePath, off_t length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Truncate a regular file to a specified length.  <a href="#ac73c92cbdac16bd6b953313163f62a95"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#ac61d622e46490a7e0be7a870fd488795">soMkdir</a> (const char *ePath, mode_t mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a directory.  <a href="#ac61d622e46490a7e0be7a870fd488795"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#a2df6b0fc3daf9498a7f6135b50c399d2">soRmdir</a> (const char *ePath)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a directory.  <a href="#a2df6b0fc3daf9498a7f6135b50c399d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#a8156e1924826324c96626e9ed7d19b72">soReaddir</a> (const char *ePath, void *buff, int32_t pos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a direntry from a directory.  <a href="#a8156e1924826324c96626e9ed7d19b72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#ac9e0b8ae91322c6bee81df15731bc524">soSymlink</a> (const char *effPath, const char *ePath)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a new name for a regular file or a directory.  <a href="#ac9e0b8ae91322c6bee81df15731bc524"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#a7cae47fa1e796132be0376b7f0091280">soReadlink</a> (const char *ePath, const char *buff, int32_t size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the value of a symbolic link.  <a href="#a7cae47fa1e796132be0376b7f0091280"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Set of operations to manage system calls. </p>
<p>(interface file)</p>
<p>The aim is to provide an unique description of the functions that operate at this level.</p>
<p>The operations are: </p>
<ul>
<li>mount the SOFS10 file system </li>
<li>unmount the SOFS10 file system </li>
<li>get file system statistics </li>
<li>get file status </li>
<li>check real user's permissions for a file </li>
<li>change permissions of a file </li>
<li>change the ownership of a file </li>
<li>make a new name for a file </li>
<li>delete the name of a file from a directory and possibly the file it refers to from the file system </li>
<li>change the name or the location of a file in the directory hierarchy of the file system </li>
<li>create a regular file with size 0 </li>
<li>open a regular file </li>
<li>close a regular file </li>
<li>read data from an open regular file </li>
<li>write data into an open regular file </li>
<li>synchronize a file's in-core state with storage device </li>
<li>create a directory </li>
<li>delete a directory </li>
<li>open a directory for reading </li>
<li>read a direntry from a directory </li>
<li>close a directory </li>
<li>make a new name for a regular file or a directory </li>
<li>read the value of a symbolic link.</li>
</ul>
<dl class="author"><dt><b>Author:</b></dt><dd>Artur Carneiro Pereira September 2007 </dd>
<dd>
Miguel Oliveira e Silva September 2009 </dd>
<dd>
António Rui Borges - October 2010 / October 2011 </dd></dl>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="af81bf1bb69be42a3b0127b001368da50"></a><!-- doxytag: member="sofs_syscalls.h::soAccess" ref="af81bf1bb69be42a3b0127b001368da50" args="(const char *ePath, int opRequested)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soAccess </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opRequested</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check real user's permissions for a file. </p>
<p>It tries to emulate <em>access</em> system call.</p>
<p>It checks whether the calling process can access the file specified by the path.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ePath</em>&nbsp;</td><td>path to the file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opRequested</em>&nbsp;</td><td>operation to be performed: F_OK (check if file exists) a bitwise combination of R_OK, W_OK, and X_OK</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> or the path string does not describe an absolute path or no operation of the defined class is described </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code>, but the last one, is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one, or the operation is denied </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a04ec0ab1233ee30ab740387f7dc50569"></a><!-- doxytag: member="sofs_syscalls.h::soChmod" ref="a04ec0ab1233ee30ab740387f7dc50569" args="(const char *ePath, mode_t mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soChmod </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change permissions of a file. </p>
<p>It tries to emulate <em>chmod</em> system call.</p>
<p>It changes the permissions of a file specified by the path.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>If the file is a symbolic link, its contents shall always be used to reach the destination file, so the permissions of a symbolic link can never be changed (they are set to rwx for <em>user</em>, <em>group</em> and <em>other</em> when the link is created and remain unchanged thereafter).</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ePath</em>&nbsp;</td><td>path to the file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>permissions to be set: a bitwise combination of S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> or the path string does not describe an absolute path or no mode of the defined class is described </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code>, but the last one, is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation is neither the file's owner, nor is <em>root</em> </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a15ab14e6f57832e96fa6560795b23deb"></a><!-- doxytag: member="sofs_syscalls.h::soChown" ref="a15ab14e6f57832e96fa6560795b23deb" args="(const char *ePath, uid_t owner, gid_t group)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soChown </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uid_t&nbsp;</td>
          <td class="paramname"> <em>owner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gid_t&nbsp;</td>
          <td class="paramname"> <em>group</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the ownership of a file. </p>
<p>It tries to emulate <em>chown</em> system call.</p>
<p>It changes the ownership of a file specified by the path.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ePath</em>&nbsp;</td><td>path to the file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>owner</em>&nbsp;</td><td>file user id (-1, if user is not to be changed) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>group</em>&nbsp;</td><td>file group id (-1, if group is not to be changed)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> or the path string does not describe an absolute path </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code>, but the last one, is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation is neither the file's owner, nor is <em>root</em>, nor the specified group is one of the owner's supplementary groups </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a6a0d4b28380c3878ac4133afd5a47845"></a><!-- doxytag: member="sofs_syscalls.h::soClose" ref="a6a0d4b28380c3878ac4133afd5a47845" args="(const char *ePath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soClose </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ePath</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close a regular file. </p>
<p>It tries to emulate <em>close</em> system call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ePath</em>&nbsp;</td><td>path to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> or the path string does not describe an absolute path </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code>, but the last one, is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EISDIR</code>, if <code>ePath</code> represents a directory </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="aaa5da9eaa7db8ac7e5246884b973608e"></a><!-- doxytag: member="sofs_syscalls.h::soClosedir" ref="aaa5da9eaa7db8ac7e5246884b973608e" args="(const char *ePath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soClosedir </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ePath</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close a directory. </p>
<p>It tries to emulate <em>closedir</em> system call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ePath</em>&nbsp;</td><td>path to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> or the path string does not describe an absolute path </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code> is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a8802ddd31f3e315d20778321251c3ce1"></a><!-- doxytag: member="sofs_syscalls.h::soFsync" ref="a8802ddd31f3e315d20778321251c3ce1" args="(const char *ePath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soFsync </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ePath</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronize a file's in-core state with storage device. </p>
<p>It tries to emulate <em>fsync</em> system call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ePath</em>&nbsp;</td><td>path to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> or the path string does not describe an absolute path </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code>, but the last one, is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a937c048ec74c55af02c40c349f85af5d"></a><!-- doxytag: member="sofs_syscalls.h::soLink" ref="a937c048ec74c55af02c40c349f85af5d" args="(const char *oldPath, const char *newPath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soLink </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>oldPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>newPath</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a new name for a file. </p>
<p>It tries to emulate <em>link</em> system call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>oldPath</em>&nbsp;</td><td>path to an existing file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newPath</em>&nbsp;</td><td>new path to the same file</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to either of the strings are <code>NULL</code> or the path strings do not describe absolute paths </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the paths names or any of their components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of both paths, but the last one, are not directories </dd>
<dd>
-<code>ELOOP</code>, if either path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>oldPath</code>, or to any of the components of <code>newPath</code>, but the last one, is found </dd>
<dd>
-<code>EEXIST</code>, if a file described by <code>newPath</code> already exists </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of both paths, but the last one </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation has not write permission on the directory where <code>newPath</code> entry is to be added, or <code>oldPath</code> represents a directory </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="ac61d622e46490a7e0be7a870fd488795"></a><!-- doxytag: member="sofs_syscalls.h::soMkdir" ref="ac61d622e46490a7e0be7a870fd488795" args="(const char *ePath, mode_t mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soMkdir </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a directory. </p>
<p>It tries to emulate <em>mkdir</em> system call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ePath</em>&nbsp;</td><td>path to the file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>type and permissions to be set: a bitwise combination of S_ISVTX, S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> or the path string does not describe an absolute path or no mode of the defined class is described </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code> is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code>, but the last one, is found </dd>
<dd>
-<code>EEXIST</code>, if a file described by <code>ePath</code> already exists or the last component is a symbolic link </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation has not write permission on the directory that will hold <code>ePath</code> </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="abc771321231500d8e3b51b25e1b9a919"></a><!-- doxytag: member="sofs_syscalls.h::soMknod" ref="abc771321231500d8e3b51b25e1b9a919" args="(const char *ePath, mode_t mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soMknod </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a regular file with size 0. </p>
<p>It tries to emulate <em>mknod</em> system call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ePath</em>&nbsp;</td><td>path to the file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>type and permissions to be set: a bitwise combination of S_IFREG, S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> or the path string does not describe an absolute path or no mode of the defined class is described </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code>, but the last one, is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code>, but the last one, is found </dd>
<dd>
-<code>EEXIST</code>, if a file described by <code>ePath</code> already exists or the last component is a symbolic link </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation has not write permission on the directory that will hold <code>ePath</code> </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a1805c069be94614ff9fd88391e8da060"></a><!-- doxytag: member="sofs_syscalls.h::soMountSOFS" ref="a1805c069be94614ff9fd88391e8da060" args="(const char *devname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soMountSOFS </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>devname</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mount the SOFS10 file system. </p>
<p>A buffered communication channel is established with the storage device. The superblock is read and it is checked if the file system was properly unmounted the last time it was mounted. If not, a consistency check is performed (presently, the check is superficial, a more thorough one is required).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>devname</em>&nbsp;</td><td>absolute path to the Linux file that simulates the storage device</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the <em>device path</em> is a <code>NULL</code> string or the magic number is not the one characteristic of SOFS11 </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the absolute path exceeds the maximum allowed length </dd>
<dd>
-<code>EBUSY</code>, if the storage area is already in use or the device is already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a3548e2dc6fc347ee7c5b42f56131407d"></a><!-- doxytag: member="sofs_syscalls.h::soOpen" ref="a3548e2dc6fc347ee7c5b42f56131407d" args="(const char *ePath, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soOpen </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open a regular file. </p>
<p>It tries to emulate <em>open</em> system call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ePath</em>&nbsp;</td><td>path to the file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>access modes to be used: O_RDONLY, O_WRONLY, O_RDWR</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> or the path string does not describe an absolute path or no access mode of the defined class is described </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code>, but the last one, is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EISDIR</code>, if <code>ePath</code> represents a directory </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation has not the proper permission (read / write) on the file described by <code>ePath</code> </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a2e4a5f041fbe2a91b5d93623e88dbe2f"></a><!-- doxytag: member="sofs_syscalls.h::soOpendir" ref="a2e4a5f041fbe2a91b5d93623e88dbe2f" args="(const char *ePath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soOpendir </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ePath</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open a directory for reading. </p>
<p>It tries to emulate <em>opendir</em> system call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ePath</em>&nbsp;</td><td>path to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> or the path string does not describe an absolute path </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code> is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation has not read permission on the directory described by <code>ePath</code> </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a8accfb94c629e0f1a22531188380def7"></a><!-- doxytag: member="sofs_syscalls.h::soRead" ref="a8accfb94c629e0f1a22531188380def7" args="(const char *ePath, void *buff, uint32_t count, int32_t pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soRead </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>pos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read data from an open regular file. </p>
<p>It tries to emulate <em>read</em> system call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ePath</em>&nbsp;</td><td>path to the file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buff</em>&nbsp;</td><td>pointer to the buffer where data to be read is to be stored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>number of bytes to be read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>starting [byte] position in the file data continuum where data is to be read from</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><em>number of bytes effectively read</em>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> or the path string does not describe an absolute path </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code>, but the last one, is not a directory </dd>
<dd>
-<code>EISDIR</code>, if <code>ePath</code> describes a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EFBIG</code>, if the starting [byte] position in the file data continuum assumes a value passing its maximum size </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation has not read permission on the file described by <code>ePath</code> </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a8156e1924826324c96626e9ed7d19b72"></a><!-- doxytag: member="sofs_syscalls.h::soReaddir" ref="a8156e1924826324c96626e9ed7d19b72" args="(const char *ePath, void *buff, int32_t pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soReaddir </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>pos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a direntry from a directory. </p>
<p>It tries to emulate <em>getdents</em> system call, but it reads a single direntry in use at a time.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The returned value is the number of bytes read from the directory in order to get the next nonempty direntry. So, skipped empty direntries must be accounted for. The point is that the system (through FUSE) uses the returned value to update file position.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ePath</em>&nbsp;</td><td>path to the file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buff</em>&nbsp;</td><td>pointer to the buffer where data to be read is to be stored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>starting [byte] position in the file data continuum where data is to be read from</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><em>number of bytes effectively read to get a direntry in use (0, if the end is reached)</em>, on success </dd>
<dd>
-<code>EINVAL</code>, if either of the pointers are <code>NULL</code> or the path string does not describe an absolute path or <em>pos</em> value is not a multiple of the size of a <em>directory entry</em> </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code> is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation has not read permission on the directory described by <code>ePath</code> </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a7cae47fa1e796132be0376b7f0091280"></a><!-- doxytag: member="sofs_syscalls.h::soReadlink" ref="a7cae47fa1e796132be0376b7f0091280" args="(const char *ePath, const char *buff, int32_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soReadlink </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read the value of a symbolic link. </p>
<p>It tries to emulate <em>readlink</em> system call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ePath</em>&nbsp;</td><td>path to the symbolic link </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buff</em>&nbsp;</td><td>pointer to the buffer where data to be read is to be stored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>buffer size in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><em>number of bytes effectively read</em>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> or the path string does not describe an absolute path or <code>ePath</code> does not represent a symbolic link </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length or the buffer size is not large enough </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code>, but the last one, is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation has not read permission on the symbolic link described by <code>ePath</code> </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="abea00e56afa699dc0a3c118304e0e15c"></a><!-- doxytag: member="sofs_syscalls.h::soRename" ref="abea00e56afa699dc0a3c118304e0e15c" args="(const char *oldPath, const char *newPath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soRename </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>oldPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>newPath</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the name or the location of a file in the directory hierarchy of the file system. </p>
<p>It tries to emulate <em>rename</em> system call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>oldPath</em>&nbsp;</td><td>path to an existing file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newPath</em>&nbsp;</td><td>new path to the same file in replacement of the old one</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to either of the strings is <code>NULL</code>, or the path strings do not describe absolute paths, or <code>oldPath</code> describes a directory and is a substring of <code>newPath</code> (attempt to make a directory a subdirectory of itself) </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the paths names or any of their components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of both paths, but the last one, are not directories, or <code>oldPath</code> describes a directory and <code>newPath</code>, although it exists, does not </dd>
<dd>
-<code>EISDIR</code>, if <code>newPath</code> describes a directory and <code>oldPath</code> does not </dd>
<dd>
-<code>ELOOP</code>, if either path resolves to more than one symbolic link </dd>
<dd>
-<code>EMLINK</code>, if <code>oldPath</code> is a directory and the directory containing <code>newPath</code> has already the maximum number of links, or <code>oldPath</code> has already the maximum number of links and is not contained in the same directory that will contain <code>newPath</code> </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>oldPath</code>, or to any of the components of <code>newPath</code>, but the last one, is found </dd>
<dd>
-<code>ENOTEMPTY</code>, if both <code>oldPath</code> and <code>newPath</code> describe directories and <code>newPath</code> is not empty </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of both paths, but the last one </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation has not write permission on the directories where <code>newPath</code> entry is to be added and <code>oldPath</code> is to be detached </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a2df6b0fc3daf9498a7f6135b50c399d2"></a><!-- doxytag: member="sofs_syscalls.h::soRmdir" ref="a2df6b0fc3daf9498a7f6135b50c399d2" args="(const char *ePath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soRmdir </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ePath</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete a directory. </p>
<p>It tries to emulate <em>rmdir</em> system call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ePath</em>&nbsp;</td><td>path to the directory to be deleted</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> or the path string does not describe an absolute path </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of the path is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>ENOTEMPTY</code>, if <code>ePath</code> describes a non-empty directory </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of the path, but the last one </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation has not write permission on the directory where <code>ePath</code> entry is to be removed </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a6ce618672344fe2b4acbb61b1a0bc281"></a><!-- doxytag: member="sofs_syscalls.h::soStat" ref="a6ce618672344fe2b4acbb61b1a0bc281" args="(const char *ePath, struct stat *st)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soStat </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct stat *&nbsp;</td>
          <td class="paramname"> <em>st</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get file status. </p>
<p>It tries to emulate <em>stat</em> system call.</p>
<p>Information about a specific file is returned. It checks whether the calling process can access the file specified by the path.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ePath</em>&nbsp;</td><td>path to the file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>st</em>&nbsp;</td><td>pointer to a stat structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if any of the pointers are <code>NULL</code> or the path string does not describe an absolute path </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code>, but the last one, is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="ac94558f3fd27529d5a81ed479025f18d"></a><!-- doxytag: member="sofs_syscalls.h::soStatFS" ref="ac94558f3fd27529d5a81ed479025f18d" args="(const char *ePath, struct statvfs *st)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soStatFS </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct statvfs *&nbsp;</td>
          <td class="paramname"> <em>st</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get file system statistics. </p>
<p>It tries to emulate <em>statvfs</em> system call.</p>
<p>Information about a mounted file system is returned. It checks whether the calling process can access the file specified by the path.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ePath</em>&nbsp;</td><td>path to any file within the mounted file system </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>st</em>&nbsp;</td><td>pointer to a statvfs structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if any of the pointers are <code>NULL</code> or the path string does not describe an absolute path </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code>, but the last one, is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="ac9e0b8ae91322c6bee81df15731bc524"></a><!-- doxytag: member="sofs_syscalls.h::soSymlink" ref="ac9e0b8ae91322c6bee81df15731bc524" args="(const char *effPath, const char *ePath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soSymlink </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>effPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ePath</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a new name for a regular file or a directory. </p>
<p>It tries to emulate <em>symlink</em> system call.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The permissions set for the symbolic link should have read (r), write (w) and execution (x) permissions for both <em>user</em>, <em>group</em> and <em>other</em>.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>effPath</em>&nbsp;</td><td>path to be stored in the symbolic link file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ePath</em>&nbsp;</td><td>path to the symbolic link</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to either of the strings are <code>NULL</code> or the second string does not describe an absolute path </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the either path names or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of the second path, but the last one, is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the second path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code>, but the last one, is found </dd>
<dd>
-<code>EEXIST</code>, if a file described by <code>ePath</code> already exists </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of the second path, but the last one </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation has not write permission on the directory where <code>ePath</code> entry is to be added </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="ac73c92cbdac16bd6b953313163f62a95"></a><!-- doxytag: member="sofs_syscalls.h::soTruncate" ref="ac73c92cbdac16bd6b953313163f62a95" args="(const char *ePath, off_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soTruncate </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Truncate a regular file to a specified length. </p>
<p>It tries to emulate <em>truncate</em> system call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ePath</em>&nbsp;</td><td>path to the file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>new size for the regular size</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> or the path string does not describe an absolute path </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code>, but the last one, is not a directory </dd>
<dd>
-<code>EISDIR</code>, if <code>ePath</code> describes a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EFBIG</code>, if the file may grow passing its maximum size </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation has not write permission on the file described by <code>ePath</code> </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a276629202749786d8c570ce67ed6f9b9"></a><!-- doxytag: member="sofs_syscalls.h::soUnlink" ref="a276629202749786d8c570ce67ed6f9b9" args="(const char *ePath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soUnlink </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ePath</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete the name of a file from a directory and possibly the file it refers to from the file system. </p>
<p>It tries to emulate <em>unlink</em> system call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ePath</em>&nbsp;</td><td>path to the file to be deleted</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> or the path string does not describe an absolute path </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of the path, but the last one, is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of the path, but the last one </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation has not write permission on the directory where <code>ePath</code> entry is to be removed </dd>
<dd>
-<code>EISDIR</code>, if <code>ePath</code> represents a directory </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a18f674558eab695015444fa77af39e6d"></a><!-- doxytag: member="sofs_syscalls.h::soUnmountSOFS" ref="a18f674558eab695015444fa77af39e6d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soUnmountSOFS </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unmount the SOFS10 file system. </p>
<p>The buffered communication channel previously established with the storage device is closed. This means, namely, that the contents of the storage area is flushed into the storage device to keep data update. Before that, however, the mount flag of the superblock is set to <em>properly unmounted</em>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a8ffec27f63bab8cbdcaab645ef3b5e49"></a><!-- doxytag: member="sofs_syscalls.h::soUtime" ref="a8ffec27f63bab8cbdcaab645ef3b5e49" args="(const char *ePath, const struct utimbuf *times)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soUtime </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct utimbuf *&nbsp;</td>
          <td class="paramname"> <em>times</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the last access and modification times of a file. </p>
<p>It tries to emulate <em>utime</em> system call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ePath</em>&nbsp;</td><td>path to the file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>times</em>&nbsp;</td><td>pointer to a structure where the last access and modification times are passed, if <code>NULL</code>, the last access and modification times are set to the current time</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> or the path string does not describe an absolute path </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code>, but the last one, is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation is neither the file's owner, nor is <em>root</em>, or has not write permission </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a3cd31d386946336f121be6a4c0c696b8"></a><!-- doxytag: member="sofs_syscalls.h::soWrite" ref="a3cd31d386946336f121be6a4c0c696b8" args="(const char *ePath, void *buff, uint32_t count, int32_t pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soWrite </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>pos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write data into an open regular file. </p>
<p>It tries to emulate <em>write</em> system call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ePath</em>&nbsp;</td><td>path to the file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buff</em>&nbsp;</td><td>pointer to the buffer where data to be written is stored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>number of bytes to be written </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>starting [byte] position in the file data continuum where data is to be written into</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><em>number of bytes effectively written</em>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> or the path string does not describe an absolute path </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code>, but the last one, is not a directory </dd>
<dd>
-<code>EISDIR</code>, if <code>ePath</code> describes a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EFBIG</code>, if the file may grow passing its maximum size </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation has not write permission on the file described by <code>ePath</code> </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
