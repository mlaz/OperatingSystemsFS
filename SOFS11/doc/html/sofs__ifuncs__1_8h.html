<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SOFS11: sofs_ifuncs_1.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>sofs_ifuncs_1.h File Reference</h1>
<p>Set of operations to manage the double-linked lists of free inodes and free data clusters: level 1 of the internal file system organization.  
<a href="#_details">More...</a></p>

<p><a href="sofs__ifuncs__1_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__1_8h.html#a70e1f3ead947a8bdef9eff20d5a88d60">soAllocInode</a> (uint32_t type, uint32_t *p_nInode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a free inode.  <a href="#a70e1f3ead947a8bdef9eff20d5a88d60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__1_8h.html#a5b2ec7229828a560e64820a6b34583e9">soFreeInode</a> (uint32_t nInode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free the referenced inode.  <a href="#a5b2ec7229828a560e64820a6b34583e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__1_8h.html#a8c857db26186dfcdfff49a582709a506">soAllocDataCluster</a> (uint32_t nInode, uint32_t *p_nClust)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a free data cluster and associate it to an inode.  <a href="#a8c857db26186dfcdfff49a582709a506"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__1_8h.html#addf61b4ba2146b452c99741c61a22cc4">soFreeDataCluster</a> (uint32_t nClust)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free the referenced data cluster.  <a href="#addf61b4ba2146b452c99741c61a22cc4"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Set of operations to manage the double-linked lists of free inodes and free data clusters: level 1 of the internal file system organization. </p>
<p>(interface file)</p>
<p>The aim is to provide an unique description of the functions that operate at this level.</p>
<p>The operations are: </p>
<ul>
<li>allocate a free inode </li>
<li>free the referenced inode </li>
<li>allocate a free data cluster </li>
<li>free the referenced data cluster.</li>
</ul>
<dl class="author"><dt><b>Author:</b></dt><dd>Artur Carneiro Pereira September 2008 </dd>
<dd>
Miguel Oliveira e Silva September 2009 </dd>
<dd>
Ant√≥nio Rui Borges - September 2010 / September 2011</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>In case an error occurs, all functions return a negative value which is the symmetric of the system error or the local error that better represents the error cause. Local errors are out of the range of the system errors. </dd></dl>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a8c857db26186dfcdfff49a582709a506"></a><!-- doxytag: member="sofs_ifuncs_1.h::soAllocDataCluster" ref="a8c857db26186dfcdfff49a582709a506" args="(uint32_t nInode, uint32_t *p_nClust)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soAllocDataCluster </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>nInode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>p_nClust</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a free data cluster and associate it to an inode. </p>
<p>The inode is supposed to be associated to a file (a regular file, a directory or a symbolic link), but the only consistency check at this stage should be to check if the inode is not free.</p>
<p>The cluster is retrieved from the retrieval cache of free data cluster references. If the cache is empty, it has to be replenished before the retrieval may take place. If the data cluster is in the dirty state, it has to be cleaned first. The header fields of the allocated cluster should be all filled in: <code>prev</code> and <code>next</code> should be set to <code>NULL_CLUSTER</code> and <code>stat</code> to the given inode number.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nInode</em>&nbsp;</td><td>number of the inode the data cluster should be associated to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_nClust</em>&nbsp;</td><td>pointer to the location where the logical number of the allocated data cluster is to be stored</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, the <em>inode number</em> is out of range or the <em>pointer to the logical data cluster number</em> is <code>NULL</code> </dd>
<dd>
-<code>ENOSPC</code>, if there are no free data clusters </dd>
<dd>
-<code>EIUININVAL</code>, if the inode in use is inconsistent </dd>
<dd>
-<code>EFDININVAL</code>, if the free inode in the dirty state is inconsistent </dd>
<dd>
-<code>ELDCININVAL</code>, if the list of data cluster references belonging to an inode is inconsistent </dd>
<dd>
-<code>EDCINVAL</code>, if the data cluster header is inconsistent </dd>
<dd>
-<code>EDCNOTIL</code>, if the referenced data cluster is not in the list of direct references </dd>
<dd>
-<code>EWGINODENB</code>, if the <em>inode number</em> in the data cluster <code>status</code> field is different from the provided <em>inode number</em> </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails reading or writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a70e1f3ead947a8bdef9eff20d5a88d60"></a><!-- doxytag: member="sofs_ifuncs_1.h::soAllocInode" ref="a70e1f3ead947a8bdef9eff20d5a88d60" args="(uint32_t type, uint32_t *p_nInode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soAllocInode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>p_nInode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a free inode. </p>
<p>The inode is retrieved from the list of free inodes, marked in use, associated to the legal file type passed as a parameter and generally initialized. It must be free and if is free in the dirty state, it has to be cleaned first.</p>
<p>Upon initialization, the new inode has: </p>
<ul>
<li>the field mode set to the given type, while the free flag and the permissions are reset </li>
<li>the owner and group fields set to current userid and groupid </li>
<li>the <em>prev</em> and <em>next</em> fields, pointers in the double-linked list of free inodes, change their meaning: they are replaced by the <em>time of last file modification</em> and <em>time of last file access</em> which are set to current time </li>
<li>the reference fields set to NULL_CLUSTER </li>
<li>all other fields reset.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>the inode type (it must represent either a file, or a directory, or a symbolic link) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_nInode</em>&nbsp;</td><td>pointer to the location where the number of the just allocated inode is to be stored</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the <em>type</em> is illegal or the <em>pointer to inode number</em> is <code>NULL</code> </dd>
<dd>
-<code>ENOSPC</code>, if the list of free inodes is empty </dd>
<dd>
-<code>EFININVAL</code>, if the free inode is inconsistent </dd>
<dd>
-<code>EFDININVAL</code>, if the free inode in the dirty state is inconsistent </dd>
<dd>
-<code>ELDCININVAL</code>, if the list of data cluster references belonging to an inode is inconsistent </dd>
<dd>
-<code>EDCINVAL</code>, if the data cluster header is inconsistent </dd>
<dd>
-<code>EWGINODENB</code>, if the <em>inode number</em> in the data cluster <code>status</code> field is different from the provided <em>inode number</em> </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails reading or writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="addf61b4ba2146b452c99741c61a22cc4"></a><!-- doxytag: member="sofs_ifuncs_1.h::soFreeDataCluster" ref="addf61b4ba2146b452c99741c61a22cc4" args="(uint32_t nClust)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soFreeDataCluster </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>nClust</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free the referenced data cluster. </p>
<p>The cluster is inserted into the insertion cache of free data cluster references. If the cache is full, it has to be depleted before the insertion may take place. The data cluster should be put in the dirty state (the <code>stat</code> of the header should remain as it is), the other fields of the header, <code>prev</code> and <code>next</code>, should be put to NULL_CLUSTER. The only consistency check to carry out at this stage is to check if the data cluster was allocated.</p>
<p>Notice that the first data cluster, supposed to belong to the file system root directory, can never be freed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nClust</em>&nbsp;</td><td>logical number of the data cluster</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, the <em>data cluster number</em> is out of range or the data cluster is not allocated </dd>
<dd>
-<code>EDCINVAL</code>, if the data cluster header is inconsistent </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails reading or writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a5b2ec7229828a560e64820a6b34583e9"></a><!-- doxytag: member="sofs_ifuncs_1.h::soFreeInode" ref="a5b2ec7229828a560e64820a6b34583e9" args="(uint32_t nInode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soFreeInode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>nInode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free the referenced inode. </p>
<p>The inode must be in use, belong to one of the legal file types and have no directory entries associated with it (refcount = 0). The inode is marked free in the dirty state and inserted in the list of free inodes.</p>
<p>Notice that the inode 0, supposed to belong to the file system root directory, can not be freed.</p>
<p>The only affected fields are: </p>
<ul>
<li>the free flag of mode field, which is set </li>
<li>the <em>time of last file modification</em> and <em>time of last file access</em> fields, which change their meaning: they are replaced by the <em>prev</em> and <em>next</em> pointers in the double-linked list of free inodes. * <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nInode</em>&nbsp;</td><td>number of the inode to be freed</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the <em>inode number</em> is out of range </dd>
<dd>
-<code>EIUININVAL</code>, if the inode in use is inconsistent </dd>
<dd>
-<code>ELDCININVAL</code>, if the list of data cluster references belonging to an inode is inconsistent </dd>
<dd>
-<code>EDCINVAL</code>, if the data cluster header is inconsistent </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails reading or writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>
</li>
</ul>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
