<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SOFS11: sofs_ifuncs_4.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>sofs_ifuncs_4.h File Reference</h1>
<p>Set of operations to manage directories and directory entries: level 4 of the internal file system organization.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="sofs__direntry_8h_source.html">sofs_direntry.h</a>&quot;</code><br/>

<p><a href="sofs__ifuncs__4_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__4_8h.html#a2024d0c565f39654f043be4601e65a6c">soGetDirEntryByPath</a> (const char *ePath, uint32_t *p_nInodeDir, uint32_t *p_nInodeEnt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an entry by path.  <a href="#a2024d0c565f39654f043be4601e65a6c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__4_8h.html#a3eca70b0687bbba94edbab2520a66eaa">soGetDirEntryByName</a> (uint32_t nInodeDir, const char *eName, uint32_t *p_nInodeEnt, uint32_t *p_idx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an entry by name.  <a href="#a3eca70b0687bbba94edbab2520a66eaa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__4_8h.html#a639ac99fba57077b1b66ded79e599961">soAddDirEntry</a> (uint32_t nInodeDir, const char *eName, uint32_t nInodeEnt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an new entry to a directory.  <a href="#a639ac99fba57077b1b66ded79e599961"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__4_8h.html#a7d76857e5dcb331402108a00f3924345">soRemoveDirEntry</a> (uint32_t nInodeDir, const char *eName)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove an entry from a directory.  <a href="#a7d76857e5dcb331402108a00f3924345"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__4_8h.html#ab2b1d32979a19de7d7858adc48963c39">soRenameDirEntry</a> (uint32_t nInodeDir, const char *oldName, const char *newName)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rename an entry of a directory.  <a href="#ab2b1d32979a19de7d7858adc48963c39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__4_8h.html#a683c0a38a52d73d362edb1f9aba5778c">soCheckDirectoryEmptiness</a> (uint32_t nInodeDir)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check a directory status of emptiness.  <a href="#a683c0a38a52d73d362edb1f9aba5778c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__4_8h.html#ac803142c0ceaeb660ed5c10cfca77e7e">soAttachDirectory</a> (uint32_t nInodeDirBase, const char *eName, uint32_t nInodeDirSub)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attach a directory entry to a directory.  <a href="#ac803142c0ceaeb660ed5c10cfca77e7e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__4_8h.html#a8e79ac83b7cdca7d106bfe85b4a14e45">soDetachDirEntry</a> (uint32_t nInodeDir, const char *eName)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detach an entry from a directory.  <a href="#a8e79ac83b7cdca7d106bfe85b4a14e45"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Set of operations to manage directories and directory entries: level 4 of the internal file system organization. </p>
<p>(interface file)</p>
<p>The aim is to provide an unique description of the functions that operate at this level.</p>
<p>The operations are: </p>
<ul>
<li>get an entry by path </li>
<li>get an entry by name </li>
<li>add an new entry to a directory </li>
<li>remove an entry from a directory </li>
<li>rename an entry of a directory </li>
<li>check a directory status of emptiness </li>
<li>attach a directory entry to a directory </li>
<li>detach a directory entry from a directory.</li>
</ul>
<dl class="author"><dt><b>Author:</b></dt><dd>Artur Carneiro Pereira September 2008 </dd>
<dd>
Miguel Oliveira e Silva September 2009 </dd>
<dd>
Ant√≥nio Rui Borges - October 2010</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>In case an error occurs, all functions return a negative value which is the symmetric of the system error or the local error that better represents the error cause. Local errors are out of the range of the system errors. </dd></dl>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a639ac99fba57077b1b66ded79e599961"></a><!-- doxytag: member="sofs_ifuncs_4.h::soAddDirEntry" ref="a639ac99fba57077b1b66ded79e599961" args="(uint32_t nInodeDir, const char *eName, uint32_t nInodeEnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soAddDirEntry </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>nInodeDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>eName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>nInodeEnt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an new entry to a directory. </p>
<p>A new entry whose name is <code>eName</code> and whose inode number is <code>nInodeEnt</code> is added to the directory associated with the inode whose number is <code>nInodeDir</code>. Thus, both inodes must be in use and belong to a legal type, the former, and to the directory type, the latter.</p>
<p>The <code>eName</code> must be a <em>base name</em> and not a <em>path</em>, that is, it can not contain the character '/'. Besides there should not already be any entry in the directory whose <em>name</em> field is <code>eName</code>.</p>
<p>Whenever the type of the inode associated to the entry to be added is of directory type, the directory is initialized by setting its contents to represent an empty directory.</p>
<p>The <em>refcount</em> field of the inode associated to the entry to be added and, when required, of the inode associated to the directory are updated. This may also happen to the <em>size</em> field of either or both inodes.</p>
<p>The process that calls the operation must have write (w) and execution (x) permissions on the directory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nInodeDir</em>&nbsp;</td><td>number of the inode associated to the directory </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eName</em>&nbsp;</td><td>pointer to the string holding the name of the directory entry to be added </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nInodeEnt</em>&nbsp;</td><td>number of the inode associated to the directory entry to be added</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if any of the <em>inode numbers</em> are out of range or the pointer to the string is <code>NULL</code> or the name string does not describe a file name </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the name string exceeds the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if the inode type whose number is <code>nInodeDir</code> is not a directory </dd>
<dd>
-<code>EEXIST</code>, if an entry with the <code>eName</code> already exists </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on the directory </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation has not write permission on the directory </dd>
<dd>
-<code>EMLINK</code>, if the maximum number of hardlinks in either one of inodes has already been attained </dd>
<dd>
-<code>EFBIG</code>, if the directory has already grown to its maximum size </dd>
<dd>
-<code>EDIRINVAL</code>, if the directory is inconsistent </dd>
<dd>
-<code>EDEINVAL</code>, if the directory entry is inconsistent </dd>
<dd>
-<code>EIUININVAL</code>, if the inode in use is inconsistent </dd>
<dd>
-<code>ELDCININVAL</code>, if the list of data cluster references belonging to an inode is inconsistent </dd>
<dd>
-<code>EDCINVAL</code>, if the data cluster header is inconsistent </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails reading or writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="ac803142c0ceaeb660ed5c10cfca77e7e"></a><!-- doxytag: member="sofs_ifuncs_4.h::soAttachDirectory" ref="ac803142c0ceaeb660ed5c10cfca77e7e" args="(uint32_t nInodeDirBase, const char *eName, uint32_t nInodeDirSub)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soAttachDirectory </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>nInodeDirBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>eName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>nInodeDirSub</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attach a directory entry to a directory. </p>
<p>A new directory entry whose name is <code>eName</code> and whose inode number is <code>nInodeDirSub</code> is attached to the directory, the <em>base directory</em>, associated to the inode whose number is <code>nInodeDirBase</code>. The entry to be attached is supposed to represent itself a fully organized directory, the <em>subsidiary directory</em>. Thus, both inodes must be in use and belong to the directory type.</p>
<p>The <code>eName</code> must be a <em>base name</em> and not a <em>path</em>, that is, it can not contain the character '/'. Besides there should not already be any entry in the base directory whose <em>name</em> field is <code>eName</code>.</p>
<p>The <em>refcount</em> field of both inodes are updated. The <em>size</em> field associated to the base directory may also be updated.</p>
<p>The process that calls the operation must have write (w) and execution (x) permissions on the directory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nInodeDirBase</em>&nbsp;</td><td>number of the inode associated to the base directory </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eName</em>&nbsp;</td><td>pointer to the string holding the name of the subsidiary directory </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nInodeDirSub</em>&nbsp;</td><td>number of the inode associated to the subsidiary directory</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if any of the <em>inode numbers</em> are out of range or the pointer to the string is <code>NULL</code> or the name string does not describe a file name </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the name string exceeds the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if the inodes do not describe directories </dd>
<dd>
-<code>EEXIST</code>, if an entry with the <code>eName</code> already exists </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on the base directory </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation has not write permission on the base directory </dd>
<dd>
-<code>EMLINK</code>, if the maximum number of hardlinks in either one of inodes has already been attained </dd>
<dd>
-<code>EFBIG</code>, if the base directory has already grown to its maximum size </dd>
<dd>
-<code>EDIRINVAL</code>, if the directory is inconsistent </dd>
<dd>
-<code>EDEINVAL</code>, if the directory entry is inconsistent </dd>
<dd>
-<code>EIUININVAL</code>, if the inode in use is inconsistent </dd>
<dd>
-<code>ELDCININVAL</code>, if the list of data cluster references belonging to an inode is inconsistent </dd>
<dd>
-<code>EDCINVAL</code>, if the data cluster header is inconsistent </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails reading or writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a683c0a38a52d73d362edb1f9aba5778c"></a><!-- doxytag: member="sofs_ifuncs_4.h::soCheckDirectoryEmptiness" ref="a683c0a38a52d73d362edb1f9aba5778c" args="(uint32_t nInodeDir)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soCheckDirectoryEmptiness </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>nInodeDir</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check a directory status of emptiness. </p>
<p>The directory contents is parsed to assert if all its entries, except for the first two, are free and are either in the clean or the dirty state. Thus, the inode associated to the directory must be in use and belong to the directory type.</p>
<p>The two first aforementioned entries must be in use and be named, respectively, "." and "..".</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nInodeDir</em>&nbsp;</td><td>number of the inode associated to the directory</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, if the directory is empty </dd>
<dd>
-<code>ENOTEMPTY</code>, if the directory is not empty </dd>
<dd>
-<code>EINVAL</code>, if the <em>inode number</em> is out of range </dd>
<dd>
-<code>ENOTDIR</code>, if the inode type is not a directory </dd>
<dd>
-<code>ENOTEMPTY</code>, if the directory is not empty </dd>
<dd>
-<code>EDIRINVAL</code>, if the directory is inconsistent </dd>
<dd>
-<code>EDEINVAL</code>, if the directory entry is inconsistent </dd>
<dd>
-<code>EIUININVAL</code>, if the inode in use is inconsistent </dd>
<dd>
-<code>ELDCININVAL</code>, if the list of data cluster references belonging to an inode is inconsistent </dd>
<dd>
-<code>EDCINVAL</code>, if the data cluster header is inconsistent </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails reading or writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a8e79ac83b7cdca7d106bfe85b4a14e45"></a><!-- doxytag: member="sofs_ifuncs_4.h::soDetachDirEntry" ref="a8e79ac83b7cdca7d106bfe85b4a14e45" args="(uint32_t nInodeDir, const char *eName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soDetachDirEntry </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>nInodeDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>eName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Detach an entry from a directory. </p>
<p>The entry whose name is <code>eName</code> is detached from the directory associated with the inode whose number is <code>nInodeDir</code>. Thus, the inode must be in use and belong to the directory type.</p>
<p>The <code>eName</code> must be a <em>base name</em> and not a <em>path</em>, that is, it can not contain the character '/'. Besides there should exist an entry in the directory whose <em>name</em> field is <code>eName</code>.</p>
<p>The <em>refcount</em> field of the inode associated to the entry to be detached and, when required, of the inode associated to the directory are updated. The entry is cleaned (that is, it becomes free in the clean state). The file described by the inode associated to the entry to be detached is only erased from the file system if the <em>refcount</em> field becomes zero (there are no more hard links associated to it). In this case, the data clusters that store the file contents must be freed and cleaned and the inode itself must be freed.</p>
<p>The process that calls the operation must have write (w) and execution (x) permissions on the directory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nInodeDir</em>&nbsp;</td><td>number of the inode associated to the directory </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eName</em>&nbsp;</td><td>pointer to the string holding the name of the directory entry to be detached</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the <em>inode number</em> is out of range or the pointer to the string is <code>NULL</code> or the name string does not describe a file name </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the name string exceeds the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if the inode type whose number is <code>nInodeDir</code> is not a directory </dd>
<dd>
-<code>ENOENT</code>, if no entry with <code>eName</code> is found </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on the directory </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation has not write permission on the directory </dd>
<dd>
-<code>ENOTEMPTY</code>, if the entry with <code>eName</code> describes a non-empty directory </dd>
<dd>
-<code>EDIRINVAL</code>, if the directory is inconsistent </dd>
<dd>
-<code>EDEINVAL</code>, if the directory entry is inconsistent </dd>
<dd>
-<code>EIUININVAL</code>, if the inode in use is inconsistent </dd>
<dd>
-<code>ELDCININVAL</code>, if the list of data cluster references belonging to an inode is inconsistent </dd>
<dd>
-<code>EDCINVAL</code>, if the data cluster header is inconsistent </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails reading or writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a3eca70b0687bbba94edbab2520a66eaa"></a><!-- doxytag: member="sofs_ifuncs_4.h::soGetDirEntryByName" ref="a3eca70b0687bbba94edbab2520a66eaa" args="(uint32_t nInodeDir, const char *eName, uint32_t *p_nInodeEnt, uint32_t *p_idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soGetDirEntryByName </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>nInodeDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>eName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>p_nInodeEnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>p_idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get an entry by name. </p>
<p>The directory contents, seen as an array of direntries, is parsed to find an entry whose name is <code>eName</code>. Thus, the inode associated to the directory must be in use and belong to the directory type.</p>
<p>The <code>eName</code> must also be a <em>base name</em> and not a <em>path</em>, that is, it can not contain the character '/'.</p>
<p>The process that calls the operation must have execution (x) permission on the directory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nInodeDir</em>&nbsp;</td><td>number of the inode associated to the directory </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eName</em>&nbsp;</td><td>pointer to the string holding the name of the directory entry to be located </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_nInodeEnt</em>&nbsp;</td><td>pointer to the location where the number of the inode associated to the directory entry whose name is passed, is to be stored (nothing is stored if <code>NULL</code>) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_idx</em>&nbsp;</td><td>pointer to the location where the index to the directory entry whose name is passed, or the index of the first entry that is free and is in the clean state, is to be stored (nothing is stored if <code>NULL</code>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the <em>inode number</em> is out of range or the pointer to the string is <code>NULL</code> or the name string does not describe a file name </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the name string exceeds the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if the inode type is not a directory </dd>
<dd>
-<code>ENOENT</code>, if no entry with <code>name</code> is found </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on the directory </dd>
<dd>
-<code>EDIRINVAL</code>, if the directory is inconsistent </dd>
<dd>
-<code>EDEINVAL</code>, if the directory entry is inconsistent </dd>
<dd>
-<code>EIUININVAL</code>, if the inode in use is inconsistent </dd>
<dd>
-<code>ELDCININVAL</code>, if the list of data cluster references belonging to an inode is inconsistent </dd>
<dd>
-<code>EDCINVAL</code>, if the data cluster header is inconsistent </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails reading or writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a2024d0c565f39654f043be4601e65a6c"></a><!-- doxytag: member="sofs_ifuncs_4.h::soGetDirEntryByPath" ref="a2024d0c565f39654f043be4601e65a6c" args="(const char *ePath, uint32_t *p_nInodeDir, uint32_t *p_nInodeEnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soGetDirEntryByPath </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>p_nInodeDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>p_nInodeEnt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get an entry by path. </p>
<p>The directory hierarchy of the file system is traversed to find an entry whose name is the rightmost component of <code>ePath</code>. The path is supposed to be absolute and each component of <code>ePath</code>, with the exception of the rightmost one, should be a directory name or symbolic link name to a path.</p>
<p>The process that calls the operation must have execution (x) permission on all the components of the path with exception of the rightmost one.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ePath</em>&nbsp;</td><td>pointer to the string holding the name of the path </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_nInodeDir</em>&nbsp;</td><td>pointer to the location where the number of the inode associated to the directory that holds the entry is to be stored (nothing is stored if <code>NULL</code>) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_nInodeEnt</em>&nbsp;</td><td>pointer to the location where the number of the inode associated to the entry is to be stored (nothing is stored if <code>NULL</code>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> or the path string does not describe an absolute path </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path or any of the path components exceed the maximum allowed length </dd>
<dd>
-<code>ERELPATH</code>, if the path is relative and it is not a symbolic link </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code>, but the last one, is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>EDIRINVAL</code>, if the directory is inconsistent </dd>
<dd>
-<code>EDEINVAL</code>, if the directory entry is inconsistent </dd>
<dd>
-<code>EIUININVAL</code>, if the inode in use is inconsistent </dd>
<dd>
-<code>ELDCININVAL</code>, if the list of data cluster references belonging to an inode is inconsistent </dd>
<dd>
-<code>EDCINVAL</code>, if the data cluster header is inconsistent </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a7d76857e5dcb331402108a00f3924345"></a><!-- doxytag: member="sofs_ifuncs_4.h::soRemoveDirEntry" ref="a7d76857e5dcb331402108a00f3924345" args="(uint32_t nInodeDir, const char *eName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soRemoveDirEntry </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>nInodeDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>eName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove an entry from a directory. </p>
<p>The entry whose name is <code>eName</code> is removed from the directory associated with the inode whose number is <code>nInodeDir</code>. Thus, the inode must be in use and belong to the directory type.</p>
<p>The <code>eName</code> must be a <em>base name</em> and not a <em>path</em>, that is, it can not contain the character '/'. Besides there should exist an entry in the directory whose <em>name</em> field is <code>eName</code>.</p>
<p>Whenever the type of the inode associated to the entry to be removed is of directory type, the operation can only be carried out if the directory is empty.</p>
<p>The <em>refcount</em> field of the inode associated to the entry to be removed and, when required, of the inode associated to the directory are updated. The file described by the inode associated to the entry to be removed is only deleted from the file system if the <em>refcount</em> field becomes zero (there are no more hard links associated to it). In this case, the data clusters that store the file contents and the inode itself must be freed.</p>
<p>The process that calls the operation must have write (w) and execution (x) permissions on the directory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nInodeDir</em>&nbsp;</td><td>number of the inode associated to the directory </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eName</em>&nbsp;</td><td>pointer to the string holding the name of the directory entry to be removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the <em>inode number</em> is out of range or the pointer to the string is <code>NULL</code> or the name string does not describe a file name </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the name string exceeds the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if the inode type whose number is <code>nInodeDir</code> is not a directory </dd>
<dd>
-<code>ENOENT</code>, if no entry with <code>eName</code> is found </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on the directory </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation has not write permission on the directory </dd>
<dd>
-<code>ENOTEMPTY</code>, if the entry with <code>eName</code> describes a non-empty directory </dd>
<dd>
-<code>EDIRINVAL</code>, if the directory is inconsistent </dd>
<dd>
-<code>EDEINVAL</code>, if the directory entry is inconsistent </dd>
<dd>
-<code>EIUININVAL</code>, if the inode in use is inconsistent </dd>
<dd>
-<code>ELDCININVAL</code>, if the list of data cluster references belonging to an inode is inconsistent </dd>
<dd>
-<code>EDCINVAL</code>, if the data cluster header is inconsistent </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails reading or writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="ab2b1d32979a19de7d7858adc48963c39"></a><!-- doxytag: member="sofs_ifuncs_4.h::soRenameDirEntry" ref="ab2b1d32979a19de7d7858adc48963c39" args="(uint32_t nInodeDir, const char *oldName, const char *newName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soRenameDirEntry </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>nInodeDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>oldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>newName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rename an entry of a directory. </p>
<p>The directory entry whose name is <code>oldName</code> has its <em>name</em> field changed to <code>newName</code>. Thus, the inode associated to the directory must be in use and belong to the directory type.</p>
<p>Both the <code>oldName</code> and the <code>newName</code> must be <em>base names</em> and not <em>paths</em>, that is, they can not contain the character '/'. Besides an entry whose <em>name</em> field is <code>oldName</code> should exist in the directory and there should not be any entry in the directory whose <em>name</em> field is <code>newName</code>.</p>
<p>The process that calls the operation must have write (w) and execution (x) permissions on the directory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nInodeDir</em>&nbsp;</td><td>number of the inode associated to the directory </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oldName</em>&nbsp;</td><td>pointer to the string holding the name of the direntry to be renamed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newName</em>&nbsp;</td><td>pointer to the string holding the new name</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the <em>inode number</em> is out of range or either one of the pointers to the strings are <code>NULL</code> or the name strings do not describe file names </dd>
<dd>
-<code>ENAMETOOLONG</code>, if one of the name strings exceeds the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if the inode type is not a directory </dd>
<dd>
-<code>ENOENT</code>, if no entry with <code>oldName</code> is found </dd>
<dd>
-<code>EEXIST</code>, if an entry with the <code>newName</code> already exists </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on the directory </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation has not write permission on the directory </dd>
<dd>
-<code>EDIRINVAL</code>, if the directory is inconsistent </dd>
<dd>
-<code>EDEINVAL</code>, if the directory entry is inconsistent </dd>
<dd>
-<code>EIUININVAL</code>, if the inode in use is inconsistent </dd>
<dd>
-<code>ELDCININVAL</code>, if the list of data cluster references belonging to an inode is inconsistent </dd>
<dd>
-<code>EDCINVAL</code>, if the data cluster header is inconsistent </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails reading or writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
