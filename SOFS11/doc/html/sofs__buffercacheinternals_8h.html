<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SOFS11: sofs_buffercacheinternals.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>sofs_buffercacheinternals.h File Reference</h1>
<p>Set of operations to internally manage the buffercache.  
<a href="#_details">More...</a></p>
<code>#include &lt;stdint.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="sofs__buffercacheinternals_8h_source.html">sofs_buffercachenode.h</a>&quot;</code><br/>

<p><a href="sofs__buffercacheinternals_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structso_buffer_cache_node.html">SOBufferCacheNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__buffercacheinternals_8h.html#a027ca2187770d3ba51edce5e6f0e6e25">getFirstNodeOnN</a> (<a class="el" href="structso_buffer_cache_node.html">SOBufferCacheNode</a> *head)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the first node of the double-linked list based on the physical block number of the storage device.  <a href="#a027ca2187770d3ba51edce5e6f0e6e25"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structso_buffer_cache_node.html">SOBufferCacheNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__buffercacheinternals_8h.html#a6b632259b6fb826bc79fddfeb61c2dc8">getNextNodeOnN</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the next node of the double-linked list based on the physical block number of the storage device.  <a href="#a6b632259b6fb826bc79fddfeb61c2dc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structso_buffer_cache_node.html">SOBufferCacheNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__buffercacheinternals_8h.html#afaab7c046066b03e7c35a5132c38703b">searchNodeOnN</a> (uint32_t nBlock, <a class="el" href="structso_buffer_cache_node.html">SOBufferCacheNode</a> *head)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a given block, whose physical number is given, has already been stored in the storage area.  <a href="#afaab7c046066b03e7c35a5132c38703b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__buffercacheinternals_8h.html#aef2f4e8f344585ec504b2d274b0d6093">insertNode</a> (<a class="el" href="structso_buffer_cache_node.html">SOBufferCacheNode</a> *node, <a class="el" href="structso_buffer_cache_node.html">SOBufferCacheNode</a> **p_nLHead, <a class="el" href="structso_buffer_cache_node.html">SOBufferCacheNode</a> **p_lATLHead, <a class="el" href="structso_buffer_cache_node.html">SOBufferCacheNode</a> **p_lATLTail)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a node in the two double-linked lists infrastructure.  <a href="#aef2f4e8f344585ec504b2d274b0d6093"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structso_buffer_cache_node.html">SOBufferCacheNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__buffercacheinternals_8h.html#ab912d39b7cf12c4a5d62a7500bc6fff3">retrieveNode</a> (<a class="el" href="structso_buffer_cache_node.html">SOBufferCacheNode</a> **p_nLHead, <a class="el" href="structso_buffer_cache_node.html">SOBufferCacheNode</a> **p_lATLHead, <a class="el" href="structso_buffer_cache_node.html">SOBufferCacheNode</a> **p_lATLTail)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve a node from the two double-linked lists infrastructure.  <a href="#ab912d39b7cf12c4a5d62a7500bc6fff3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__buffercacheinternals_8h.html#a3acdd012b62e852d830a43d7bbffde49">moveNodeAtHeadLAT</a> (<a class="el" href="structso_buffer_cache_node.html">SOBufferCacheNode</a> *node, <a class="el" href="structso_buffer_cache_node.html">SOBufferCacheNode</a> **p_lATLHead, <a class="el" href="structso_buffer_cache_node.html">SOBufferCacheNode</a> **p_lATLTail)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move the node to the head of the double-linked list based on last access time.  <a href="#a3acdd012b62e852d830a43d7bbffde49"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Set of operations to internally manage the buffercache. </p>
<p>(interface file)</p>
<p>The buffercache is conceived as two double-linked lists: the first, based on the physical block number of the storage device it is referencing; the second, based on the order of last access to the block. Hence, one needs to define operations to insert, retrieve and access its nodes. One should notice that this module does not stand alone: it supposes a very tight coupling with the buffercache implementation, its only application.</p>
<p>The following operations are defined: </p>
<ul>
<li>access the first node of the double-linked list based on the physical block number of the storage device </li>
<li>access the next node of the double-linked list based on the physical block number of the storage device </li>
<li>check if a given block, whose physical number is given, has already been stored in the storage area </li>
<li>insert a node in the two double-linked lists infrastructure </li>
<li>retrieve a node from the two double-linked lists infrastructure </li>
<li>move a node already present in the storage area to the head of the double-linked list based on the last access time.</li>
</ul>
<dl class="author"><dt><b>Author:</b></dt><dd>Ant√≥nio Rui Borges - July 2010 / August 2011 </dd></dl>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a027ca2187770d3ba51edce5e6f0e6e25"></a><!-- doxytag: member="sofs_buffercacheinternals.h::getFirstNodeOnN" ref="a027ca2187770d3ba51edce5e6f0e6e25" args="(SOBufferCacheNode *head)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structso_buffer_cache_node.html">SOBufferCacheNode</a>* getFirstNodeOnN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structso_buffer_cache_node.html">SOBufferCacheNode</a> *&nbsp;</td>
          <td class="paramname"> <em>head</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access the first node of the double-linked list based on the physical block number of the storage device. </p>
<p>An iterator internal variable is set to the value of the argument and a pointer to the node pointed to by the iterator variable is returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>head</em>&nbsp;</td><td>pointer to the head of the linked list based on the physical block number of the storage device</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>value of the <em>iterator</em> variable </dd></dl>

</div>
</div>
<a class="anchor" id="a6b632259b6fb826bc79fddfeb61c2dc8"></a><!-- doxytag: member="sofs_buffercacheinternals.h::getNextNodeOnN" ref="a6b632259b6fb826bc79fddfeb61c2dc8" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structso_buffer_cache_node.html">SOBufferCacheNode</a>* getNextNodeOnN </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access the next node of the double-linked list based on the physical block number of the storage device. </p>
<p>The iterator internal variable is iterated if it does not already point to the last node of the linked list, and a pointer to the node pointed to by the iterator variable is returned.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>value of the <em>iterator</em> variable </dd></dl>

</div>
</div>
<a class="anchor" id="aef2f4e8f344585ec504b2d274b0d6093"></a><!-- doxytag: member="sofs_buffercacheinternals.h::insertNode" ref="aef2f4e8f344585ec504b2d274b0d6093" args="(SOBufferCacheNode *node, SOBufferCacheNode **p_nLHead, SOBufferCacheNode **p_lATLHead, SOBufferCacheNode **p_lATLTail)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insertNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structso_buffer_cache_node.html">SOBufferCacheNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structso_buffer_cache_node.html">SOBufferCacheNode</a> **&nbsp;</td>
          <td class="paramname"> <em>p_nLHead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structso_buffer_cache_node.html">SOBufferCacheNode</a> **&nbsp;</td>
          <td class="paramname"> <em>p_lATLHead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structso_buffer_cache_node.html">SOBufferCacheNode</a> **&nbsp;</td>
          <td class="paramname"> <em>p_lATLTail</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a node in the two double-linked lists infrastructure. </p>
<p>A node whose contents belongs to a block of the storage device, which is supposed not to be stored in the storage area yet, is inserted in the two double-linked lists infrastructure. If the node is already present or the storage area is inconsistent, nothing is done.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>pointer to the node to be inserted </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_nLHead</em>&nbsp;</td><td>pointer to a location where the pointer to the head of the double linked list based on the physical block number of the storage device, is stored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_lATLHead</em>&nbsp;</td><td>pointer to a location where the pointer to the head of the double-linked list based on the last access time, is stored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_lATLTail</em>&nbsp;</td><td>pointer to a location where the pointer to the tail of the double-linked list based on the last access time, is stored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3acdd012b62e852d830a43d7bbffde49"></a><!-- doxytag: member="sofs_buffercacheinternals.h::moveNodeAtHeadLAT" ref="a3acdd012b62e852d830a43d7bbffde49" args="(SOBufferCacheNode *node, SOBufferCacheNode **p_lATLHead, SOBufferCacheNode **p_lATLTail)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void moveNodeAtHeadLAT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structso_buffer_cache_node.html">SOBufferCacheNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structso_buffer_cache_node.html">SOBufferCacheNode</a> **&nbsp;</td>
          <td class="paramname"> <em>p_lATLHead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structso_buffer_cache_node.html">SOBufferCacheNode</a> **&nbsp;</td>
          <td class="paramname"> <em>p_lATLTail</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Move the node to the head of the double-linked list based on last access time. </p>
<p>The node which is supposed to have been accessed, is retrieved from its location in the double-linked list based on the last access time and placed at the head of the list. If the node pointer is <code>NULL</code> or the storage area is inconsistent, nothing is done.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>pointer to the node to be inserted </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_lATLHead</em>&nbsp;</td><td>pointer to a location where the pointer to the head of the double-linked list based on the last access time, is stored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_lATLTail</em>&nbsp;</td><td>pointer to a location where the pointer to the tail of the double-linked list based on the last access time, is stored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab912d39b7cf12c4a5d62a7500bc6fff3"></a><!-- doxytag: member="sofs_buffercacheinternals.h::retrieveNode" ref="ab912d39b7cf12c4a5d62a7500bc6fff3" args="(SOBufferCacheNode **p_nLHead, SOBufferCacheNode **p_lATLHead, SOBufferCacheNode **p_lATLTail)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structso_buffer_cache_node.html">SOBufferCacheNode</a>* retrieveNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structso_buffer_cache_node.html">SOBufferCacheNode</a> **&nbsp;</td>
          <td class="paramname"> <em>p_nLHead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structso_buffer_cache_node.html">SOBufferCacheNode</a> **&nbsp;</td>
          <td class="paramname"> <em>p_lATLHead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structso_buffer_cache_node.html">SOBufferCacheNode</a> **&nbsp;</td>
          <td class="paramname"> <em>p_lATLTail</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve a node from the two double-linked lists infrastructure. </p>
<p>The node which the tail of the double-linked list based on last access time points to, is retrieved from the two double-linked lists infrastructure. If the storage area is inconsistent, nothing is done.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_nLHead</em>&nbsp;</td><td>pointer to a location where the pointer to the head of the double linked list based on the physical block number of the storage device, is stored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_lATLHead</em>&nbsp;</td><td>pointer to a location where the pointer to the head of the double-linked list based on the last access time, is stored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_lATLTail</em>&nbsp;</td><td>pointer to a location where the pointer to the tail of the double-linked list based on the last access time, is stored</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the retrieved node, or <code>NULL</code> if the storage area is empty or inconsistent </dd></dl>

</div>
</div>
<a class="anchor" id="afaab7c046066b03e7c35a5132c38703b"></a><!-- doxytag: member="sofs_buffercacheinternals.h::searchNodeOnN" ref="afaab7c046066b03e7c35a5132c38703b" args="(uint32_t nBlock, SOBufferCacheNode *head)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structso_buffer_cache_node.html">SOBufferCacheNode</a>* searchNodeOnN </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>nBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structso_buffer_cache_node.html">SOBufferCacheNode</a> *&nbsp;</td>
          <td class="paramname"> <em>head</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if a given block, whose physical number is given, has already been stored in the storage area. </p>
<p>The double-linked list based on the physical block number of the storage device is traversed from the node pointed to by the second argument to find out if there is a node whose contents belongs to the block whose physical number is passed as the first argument.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nBlock</em>&nbsp;</td><td>physical block number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>head</em>&nbsp;</td><td>pointer to the head of the linked list based on the block number of the storage device</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the node where the block contents is stored, or <code>NULL</code> if the block has not been stored yet </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
