<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SOFS11: sofs_ifuncs_2.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>sofs_ifuncs_2.h File Reference</h1>
<p>Set of operations to manage inodes: level 2 of the internal file system organization.  
<a href="#_details">More...</a></p>
<code>#include &lt;stdint.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="sofs__inode_8h_source.html">sofs_inode.h</a>&quot;</code><br/>

<p><a href="sofs__ifuncs__2_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cfb6a601857f6df85b22cf3971300dd"></a><!-- doxytag: member="sofs_ifuncs_2.h::IUIN" ref="a4cfb6a601857f6df85b22cf3971300dd" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__2_8h.html#a4cfb6a601857f6df85b22cf3971300dd">IUIN</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">inode in use status <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4f481854b4f492803a20c275df14ddc"></a><!-- doxytag: member="sofs_ifuncs_2.h::FDIN" ref="ad4f481854b4f492803a20c275df14ddc" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__2_8h.html#ad4f481854b4f492803a20c275df14ddc">FDIN</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">free inode in dirty state status <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c71a5e59a53413cd6c270266d63b031"></a><!-- doxytag: member="sofs_ifuncs_2.h::R" ref="a5c71a5e59a53413cd6c270266d63b031" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__2_8h.html#a5c71a5e59a53413cd6c270266d63b031">R</a>&nbsp;&nbsp;&nbsp;0x0004</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">performing a read operation <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a649b8f01fd6c0f47ff3cbddaeba63bfb"></a><!-- doxytag: member="sofs_ifuncs_2.h::W" ref="a649b8f01fd6c0f47ff3cbddaeba63bfb" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__2_8h.html#a649b8f01fd6c0f47ff3cbddaeba63bfb">W</a>&nbsp;&nbsp;&nbsp;0x0002</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">performing a write operation <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a207fd5507206d307cd63f95374fcd00d"></a><!-- doxytag: member="sofs_ifuncs_2.h::X" ref="a207fd5507206d307cd63f95374fcd00d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__2_8h.html#a207fd5507206d307cd63f95374fcd00d">X</a>&nbsp;&nbsp;&nbsp;0x0001</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">performing an execute operation <br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__2_8h.html#a224ca63a9e45adfbd33c22c34446bd86">soReadInode</a> (<a class="el" href="structso_inode.html">SOInode</a> *p_inode, uint32_t nInode, uint32_t status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read specific inode data from the table of inodes.  <a href="#a224ca63a9e45adfbd33c22c34446bd86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__2_8h.html#a4d919d7f37210bd618ffe9b3f3acd094">soWriteInode</a> (<a class="el" href="structso_inode.html">SOInode</a> *p_inode, uint32_t nInode, uint32_t status)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write specific inode data to the table of inodes.  <a href="#a4d919d7f37210bd618ffe9b3f3acd094"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__2_8h.html#a943e25f7bb8993066202df65ea0406f4">soCleanInode</a> (uint32_t nInode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clean an inode.  <a href="#a943e25f7bb8993066202df65ea0406f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__2_8h.html#a143cbbf658e9ed50657ebdd13d2eb832">soAccessGranted</a> (uint32_t nInode, uint32_t opRequested)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check the inode access rights against a given operation.  <a href="#a143cbbf658e9ed50657ebdd13d2eb832"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Set of operations to manage inodes: level 2 of the internal file system organization. </p>
<p>(interface file)</p>
<p>The aim is to provide an unique description of the functions that operate at this level.</p>
<p>The operations are: </p>
<ul>
<li>read specific inode data from the table of inodes </li>
<li>write specific inode data to the table of inodes </li>
<li>clean an inode </li>
<li>check the inode access permissions against a given operation.</li>
</ul>
<dl class="author"><dt><b>Author:</b></dt><dd>Artur Carneiro Pereira September 2008 </dd>
<dd>
Miguel Oliveira e Silva September 2009 </dd>
<dd>
Ant√≥nio Rui Borges - September 2010 / September 2011</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>In case an error occurs, all functions return a negative value which is the symmetric of the system error or the local error that better represents the error cause. Local errors are out of the range of the system errors. </dd></dl>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a143cbbf658e9ed50657ebdd13d2eb832"></a><!-- doxytag: member="sofs_ifuncs_2.h::soAccessGranted" ref="a143cbbf658e9ed50657ebdd13d2eb832" args="(uint32_t nInode, uint32_t opRequested)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soAccessGranted </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>nInode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>opRequested</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check the inode access rights against a given operation. </p>
<p>The inode must to be in use and belong to one of the legal file types. It checks if the inode mask permissions allow a given operation to be performed.</p>
<p>When the calling process is <em>root</em>, access to reading and/or writing is always allowed and access to execution is allowed provided that either <em>user</em>, <em>group</em> or <em>other</em> have got execution permission.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nInode</em>&nbsp;</td><td>number of the inode </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opRequested</em>&nbsp;</td><td>operation to be performed: a bitwise combination of R, W, and X</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if <em>buffer pointer</em> is <code>NULL</code> or no operation of the defined class is described </dd>
<dd>
-<code>EACCES</code>, if the operation is denied </dd>
<dd>
-<code>EIUININVAL</code>, if the inode in use is inconsistent </dd>
<dd>
-<code>ELDCININVAL</code>, if the list of data cluster references belonging to an inode is inconsistent </dd>
<dd>
-<code>EDCINVAL</code>, if the data cluster header is inconsistent </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails reading or writing </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a943e25f7bb8993066202df65ea0406f4"></a><!-- doxytag: member="sofs_ifuncs_2.h::soCleanInode" ref="a943e25f7bb8993066202df65ea0406f4" args="(uint32_t nInode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soCleanInode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>nInode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clean an inode. </p>
<p>The inode must be free in the dirty state. The inode is supposed to be associated to a file, a directory, or a symbolic link which was previously deleted.</p>
<p>This function cleans the list of data cluster references.</p>
<p>Notice that the inode 0, supposed to belong to the file system root directory, can not be cleaned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nInode</em>&nbsp;</td><td>number of the inode</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the <em>inode number</em> is out of range </dd>
<dd>
-<code>EFDININVAL</code>, if the free inode in the dirty state is inconsistent </dd>
<dd>
-<code>ELDCININVAL</code>, if the list of data cluster references belonging to an inode is inconsistent </dd>
<dd>
-<code>EDCINVAL</code>, if the data cluster header is inconsistent </dd>
<dd>
-<code>EWGINODENB</code>, if the <em>inode number</em> in the data cluster <code>status</code> field is different from the provided <em>inode number</em> (FREE AND CLEAN / CLEAN) </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails reading or writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a224ca63a9e45adfbd33c22c34446bd86"></a><!-- doxytag: member="sofs_ifuncs_2.h::soReadInode" ref="a224ca63a9e45adfbd33c22c34446bd86" args="(SOInode *p_inode, uint32_t nInode, uint32_t status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soReadInode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structso_inode.html">SOInode</a> *&nbsp;</td>
          <td class="paramname"> <em>p_inode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>nInode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read specific inode data from the table of inodes. </p>
<p>The inode may be either in use and belong to one of the legal file types or be free in the dirty state. Upon reading, the <em>time of last file access</em> field is set to current time, if the inode is in use.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_inode</em>&nbsp;</td><td>pointer to the buffer where inode data must be read into </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nInode</em>&nbsp;</td><td>number of the inode to be read from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>inode status (in use / free in the dirty state)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the <em>buffer pointer</em> is <code>NULL</code> or the <em>inode number</em> is out of range or the inode status is invalid </dd>
<dd>
-<code>EIUININVAL</code>, if the inode in use is inconsistent </dd>
<dd>
-<code>EFDININVAL</code>, if the free inode in the dirty state is inconsistent </dd>
<dd>
-<code>ELDCININVAL</code>, if the list of data cluster references belonging to an inode is inconsistent </dd>
<dd>
-<code>EDCINVAL</code>, if the data cluster header is inconsistent </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails reading or writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a4d919d7f37210bd618ffe9b3f3acd094"></a><!-- doxytag: member="sofs_ifuncs_2.h::soWriteInode" ref="a4d919d7f37210bd618ffe9b3f3acd094" args="(SOInode *p_inode, uint32_t nInode, uint32_t status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soWriteInode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structso_inode.html">SOInode</a> *&nbsp;</td>
          <td class="paramname"> <em>p_inode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>nInode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write specific inode data to the table of inodes. </p>
<p>The inode may be either in use and belong to one of the legal file types or be free in the dirty state. Upon writing, the <em>time of last file modification</em> and <em>time of last file access</em> fields are set to current time, if the inode is in use.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_inode</em>&nbsp;</td><td>pointer to the buffer containing the data to be written from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nInode</em>&nbsp;</td><td>number of the inode to be written into </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>inode status (in use / free in the dirty state)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the <em>buffer pointer</em> is <code>NULL</code> or the <em>inode number</em> is out of range or the inode status is invalid </dd>
<dd>
-<code>EIUININVAL</code>, if the inode in use is inconsistent </dd>
<dd>
-<code>EFDININVAL</code>, if the free inode in the dirty state is inconsistent </dd>
<dd>
-<code>ELDCININVAL</code>, if the list of data cluster references belonging to an inode is inconsistent </dd>
<dd>
-<code>EDCINVAL</code>, if the data cluster header is inconsistent </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails reading or writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
